# -Java-
大话设计模式的代码

# 第一章 简单工厂模式

## 主要通过一个简单的例子，实现一个计算器来讲解面向对象的基本概念（继承、封装、多态）。
- 封装：通过定义一个Operation类，让其在内部实现加减乘除的逻辑运算，外部只要调运其方法即可
- 继承：父类OPeration只是定义了方法，没有具体实现，具体的方法有子类进行实现
- 多态：父类引用子类对象
***
简单工厂模式：对象的创建不需要自己去new，通过调用工厂类Factory的方法来返回需要的对象。优点是：需要增加新的功能时，只需要创建新的子类，
并修改工厂类即可。

# 第二章 策略模式

策略模式（strategy）：它定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到算法的客户。

## 例子：商场收银系统（打折、满减等功能）
- 面向对象编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类。
  v1中使用的便是上章讲的简单工厂模式，但这个模式只是解决了对象创建的问题。
  v2中使用的便是策略模式，打折、返利本质上一些算法，用简单工厂来生成算法对象，并没有错，但算法本身一种策略，这些算法是随时会被替换的，
    这就是变化点，而封装变化点是面向对象的一种重要思维方式。
    
## 策略模式解析
策略模式中一系列的算法本质上完成的是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法类，减少了**算法类**与**使用算法类**之
间的耦合。具体的几个部分：Strategy、Context、具体实现算法的类

优点：Stragy利用继承抽象出不同具体算法的功能来给Context用。并且可以简化算法的单元测试，每个算法都有自己单独的类。

注：在不同行为堆砌在一个类时，就很难避免使用条件语句来选择合适的行为。基本的策略模式中，选择所用具体实现的职责由客户端承担，并转给
策略模式的Context。但当其与简单工厂类结合时，选择具体实现的职责便可以交给context来承担，大大减轻了客户端的之策。

# 第三章 单一职责原则

# 第四章 开放-封闭原则

# 第五章 依赖倒置原则

# 第六章 装饰器模式
装饰器模式（Decorator）动态地给一个对象添加一些额外的职责，就功能来说，装饰器比生成子类更为灵活
主要部分：Component(抽象构件)、ConcreateComponent(具体构件)、Decorator(抽象装饰类)、ConcreteDecoratorA(具体装饰类)

使用场合：为已有的功能动态的添加其他的功能
优点：把每个要装饰的功能放在单独的类，让这个类来包装要装饰的对象，这样就可以有选择、有顺序的使用装饰类了。


# 第七章 代理模式
主要部分：Subject(抽主题角色)、Proxy(代理主题角色)、RealSubject(真是主题角色)

使用场合：第一，远程代理。第二，虚拟代理。第三，安全代理。第四，只能代理
Java中的代理：jdk动态代理（需要接口）、cglib动态代理（不需要接口）（实现AOP的原理）


